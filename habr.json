[
     {
          "time": "2023-12-25T11:10:32.000Z",
          "header": "remember «Forever». Как сохранить скролл при уходе с экрана",
          "link": "https://habr.com/ru/articles/783004/",
          "text": "Всем привет! Настало время рассказать про то о чем compose умалчивает. Это проблема сохранения состояний при переходе между экранами. В нашем приложении много скроллящихся экранов, поэтому первое, что мы хотели сохранить было именно состояние скролла. Идею можно пошарить на все, но говорить будем именно про скролл.Немного о себеЯвляюсь лидом мобильной команды разработки в финтех компании Peter Partner. Мы реализовали систему по автоматизации торговли, которая интегрирована с крупными торговыми брокерами. Проект локализован на множество языков и им пользуется свыше 1 млн. человек в странах Азии, Африки и Южной Америки.Что мы имеемПридумаем какое-то приложение с минимум экрановУ нас есть 3 экрана в нижней навигации и еще на два можно перейти последовательно. На каждом из экранов есть LazyColumn или еще чего-то, что умеет скроллитьсяСтек у нас следующий:ComposeKMPнавигация любая где есть доступ к backStackЧто хотимПереход между экранами с запоминанием состояния скролла.Переход на новый экран на \"верх\"Если на экране есть вложенный скролл его тоже запомнить(horizontal pager, lazy row и другие)РеализацияДелать все будем по порядку.Для начала нам нужна какая-то модель того как будем хранить эти состояния. Я не смог придумать ничего лучше чем оставить это просто в статике.Интересный факт. За два года существования решения это так и не вызвало никаких проблем. // тут будет храниться все что скроллиться на экране.\n// Ключ - название экрана, значение - список ScrollState\n// на одном экране может быть больше одного такого элемента.\n// Пример:\n// LazyColumn{\n//   item{\n//     LazyRow{image()}\n//   }\n//   item{\n//     LazyRow{text()}\n//   }\n// }\nprivate val SaveMap = mutableMapOf<String, MutableList<KeyParams>>()\n\nprivate val lastScreenName: String?\n    get() = здесь нам нужен уникальный ключ для текущего экрана.\n            под текущим понимается тот куда переходим.\n\nprivate class KeyParams(\n    // Это ключ для вложенного списка. \n    // Если на экране будет только один скроллящийся элемент \n    // это поле будет пустым\n    val params: String,\n    val index: Int,\n    val scrollOffset: Int,\n)Теперь нам нужно это как-то заполнить. Рассмотрим на примере классического ScrollState.@Composable\nfun rememberForeverScrollState(\n    params: String = \"\",\n): ScrollState {\n    // вероятно у вас lastScreenName всегда будет не null,\n    // но в нашем случае это поле может быть null из-за того,\n    // что первый экран не фиксирован и определяется во время splash screen \n    val key = lastScreenName ?: return rememberScrollState()\n    // rememberSaveable - кому интересно сам сможет почитать \n    // в чем разница между ним и обычным remember\n    val scrollState = rememberSaveable(saver = ScrollState.Saver) {\n        val savedValue = getSavedValue(key, params)\n        // получаем новый экземпляр ScrollState с нужным нам состоянием\n        ScrollState(initial = savedValue?.scrollOffset.orDefault())\n    }\n    // Как только мы ушли с экрана нам нужно \n    // сохранить текущее состояние\n    DisposableEffect(Unit) {\n        onDispose {\n            val lastOffset = scrollState.value\n            // кладем значение в SaveMap\n            addNewValue(\n                key = key,\n                params = KeyParams(\n                    params = params,\n                    index = 0,// у ScrollState условно только один \n                              // элемент в списке\n                    scrollOffset = lastOffset\n                )\n            )\n        }\n    }\n    return scrollState\n}\n\n// Ищем сохраненное значение. \n// key - название экрана\n// params - тег элемента\nprivate fun getSavedValue(key: String, params: String): KeyParams? =\n    SaveMap[key]?.firstOrNull { it.params == params }\n\nprivate fun addNewValue(key: String, params: KeyParams) {\n    val backStack = //ваша реализация для получения backStack экранов\n    // если мы нажали назад на экране то и сохранять ничего не нужно. \n    // Могут быть и другие варианты перехода. \n    // например, дальше без возможности вернуться (с очисткой стека)\n    if (backStack.none { it.name == key }) return\n    val savedList = SaveMap[key]\n    when {\n        //нету сохраненных значений\n        savedList == null -> SaveMap[key] = mutableListOf(params)\n        //не знаю как, но обработать надо\n        savedList.isEmpty() -> savedList.add(params)\n        else -> {\n            val existsValueIndex = savedList.indexOfFirst { it.params == params.params }\n            if (existsValueIndex >= 0) {\n                //обновление существующего элемента\n                savedList[existsValueIndex] = params\n            } else {\n                //добавление нового\n                savedList.add(params)\n            }\n        }\n    }\n}\nЕще несколько реализацийLazyListState@Composable\nfun rememberForeverLazyListState(\n    params: String = \"\",\n): LazyListState {\n    val key = lastScreenName ?: return rememberLazyListState()\n    val scrollState = rememberSaveable(saver = LazyListState.Saver) {\n        val savedValue = getSavedValue(key, params)\n        LazyListState(\n            savedValue?.index.orDefault(),\n            savedValue?.scrollOffset.orDefault()\n        )\n    }\n    DisposableEffect(params) {\n        onDispose {\n            val lastIndex = scrollState.firstVisibleItemIndex\n            val lastOffset = scrollState.firstVisibleItemScrollOffset\n            addNewValue(key, KeyParams(params, lastIndex, lastOffset))\n        }\n    }\n    return scrollState\n}PagerState@Composable\nfun rememberForeverPagerState(\n    initialPage: Int = 0,\n    params: String = \"\",\n    pageCount: () -> Int,\n): PagerState {\n    val pagerParams = params + \"Pager\"\n    val key = lastScreenName ?: return rememberPagerState(\n        initialPage = initialPage,\n        pageCount = pageCount,\n    )\n    val savedValue = remember { getSavedValue(key, pagerParams) }\n    val pagerState = rememberPagerState(\n        initialPage = savedValue?.index.orDefault(initialPage),\n        pageCount = pageCount,\n    )\n    DisposableEffect(pagerParams) {\n        onDispose {\n            val lastIndex = pagerState.currentPage\n            addNewValue(key, KeyParams(pagerParams, lastIndex, 0))\n        }\n    }\n    return pagerState\n}\nCollapseState@Composable\nfun rememberForeverCollapseState(\n    isCollapsed: Boolean = true,\n    params: String = \"\",\n): MutableState<Boolean> {\n    val pagerParams = params + \"Collapse\"\n    val key = lastScreenName ?: return remember {\n        mutableStateOf(isCollapsed)\n    }\n\n    val collapseState = rememberSaveable(saver = CollapseStateSaver) {\n        val savedValue = getSavedValue(key, pagerParams)\n        mutableStateOf(savedValue?.index?.let { it == 0 }.orDefault(isCollapsed))\n    }\n    DisposableEffect(pagerParams) {\n        onDispose {\n            val lastIndex = if (collapseState.value) 0 else 1\n            addNewValue(key, KeyParams(pagerParams, lastIndex, 0))\n        }\n    }\n    return collapseState\n}\n\nval CollapseStateSaver: Saver<MutableState<Boolean>, *> = Saver(\n    save = {\n        it.value\n    },\n    restore = {\n        mutableStateOf(it)\n    }\n)Как пример того что так можно хранить не только скролл.Как это все вызвать? Смотрим нижеval pagerState = rememberForeverPagerState() { tabs.size }\nHorizontalPager(\n    state = pagerState,\n) { page ->\n    LazyColumn(\n      state = rememberForeverLazyListState(params = page.name),\n    ){}\n}Теперь пункты один и три выполнены. Мы можем сохранять все, что хотели. Но проблема в том, что теперь появился пункт два которого изначально не было.// Обработчик вашей навигации\nLaunchedEffect {\n    navigation\n        .collect { screen ->\n            //Удаляем все лишнее\n            invalidateScrollSaveMap()\n            //Навигируемся туда куда нужно\n            navController.value = screen\n        }\n}\n\n// Удаляем все экраны из памяти которых там нету. \n// Так как по одному ключу хранятся состояния всех ScrollState,\n// то весь экран будет сброшен до стандартных значение\nfun invalidateScrollSaveMap() {\n    val keys = SaveMap.keys\n    val backStackNow = backStack.map { it.screen.name }\n    val keysForRemove = keys.filterNot { backStackNow.contains(it) }\n    keysForRemove.forEach {\n        SaveMap.remove(it)\n    }\n}\n ИтогЗапускаем приложение и магия случалась. Все работает как и должно.Спасибо всем кто дочитал до конца! Это не первая реализация данного метода, но в итоге получилось что-то действительно работающее с минимум вложений при написании. А если у Вас есть другое решение или идеи как улучшить это, то пишите в комментарии, буду рад почитать другие мнения!  "
     },
     {
          "time": "2023-12-25T11:00:01.000Z",
          "header": "Спутник против мусора",
          "link": "https://habr.com/ru/companies/ruvds/articles/782994/",
          "text": "\n\r\nПомните нашу игру «Атомный Графъ»? Если что, очень рекомендуем ознакомиться. А сейчас у нас новая больная фантазия разработка — игра «Спутник против мусора». Название говорящие: вы в виде своего альтерэго — спутника — летаете в околоземном пространстве и уворачиваетесь от всякой фигни, кружащейся вокруг Земли. Что-то даже можно будет испарить лазером, такой вот вы милитаристский аппарат. Хотя нет, конечно же, мы вдохновлялись совсем другим: 11 июля 2023 года наш пикоспутник с космическим сервером отделился от пускового контейнера и стал вольным птахом. И мы где-то в глубине души, совсем на донышке, волновались, не столкнётся ли спутник с каким-нибудь космическим мусором.\n\nОпять вы какую-то дичь придумали?\r\nВообще ни разу! О проблеме космического мусора говорят много лет, и сейчас — всё громче. Дело в том, что примерно за 70 лет освоения космоса мы умудрились загадить всё вокруг каким-то невообразимым количеством обломков и прочего неликвида. В пространстве радиусом в половину пути до Луны летает:\n\n\n\n\nРазмер\nВсего\nНа околоземной орбите (до 2000 км)\n\n\n0,1—1 см\n130 млн (!)\n20 млн\n\n\n1—10 см\n900 тыс.\n500 тыс.\n\n\nБольше 10 см\n34 тыс.\n23 тыс\n\n\nЛетаешь в каком-то супе с клёцками. Мы за чистоту во всех смыслах, в том числе вокруг планеты. И это не какой-то невроз, а очень практичная забота: существует вполне себе неиллюзорная вероятность, что количество мусора в околоземном пространстве достигнет уровня, при котором это пространство окажется недоступно для нас. Это называется эффектом Кесслера: любой выводимый в космос аппарат неизбежно будет повреждаться или сразу уничтожаться из-за столкновений с кружащимися вокруг планеты обломками, при этом порождая ещё больше обломков-мусора.\n\r\nК счастью, именно наш спутник можно считать «экологически чистым»: он очень маленький и летает на такой высоте, где последние остатки атмосферы будут ощутимо замедлять его скорость, из-за чего он скоро упадёт и сгорит без следа маленьким метеором.\n\r\nНо вся эта история с космическим мусором подкинула нам идею игры. За основу игрового процесса мы взяли аркаду «Asteroids», первая версия которой — чёрно-белая, с «проволочной» графикой» — вышла аж в 1979-м. Конечно, сохранять эстетику оригинала было бы сегодня чересчур глупо эксцентрично, поэтому графику мы облагородили. И добавили альтернативный игровой режим, о котором расскажем ниже.\n\nПерсонажи\r\nФормально, персонаж тут один — вы спутник. Все остальные — его эпизодические и множественные антагонисты. И некоторых придумал для вас Ричард Грей, тот самый дизайнер уровней в Duke Nukem, который помогал нам создавать и «Атомного Графа»! Ричард с душой подошёл к придумыванию персонажей для нашей игры, каждого обогатил увесистой историей. Правда, в финальную версию вошли не все его предложения. Всё-таки патриарх игростроя вырос и жил в англосаксонской культуре с её клише про водку, медведей, balalaika и perestroyka. А некоторые шутки Ричарда завязаны на игру слов в английском и забугорную попкультуру, поэтому оценить их смогут не только лишь все. Он вдохновлялся «Спутником» и Лайкой, романом Лема «Солярис», фильмами «Космическая одиссея 2001», «Клоуны-убийцы из космоса» и «Чужой», и даже всем вам известными буржуйскими сетями общепита. Широкий кругозор, уважаем!\n\r\nВ общем, из идей Ричарда мы взяли игровой режим с чёрными дырами и яйца ксеноморфа из «Чужого»:\n\nHellen Griplee, Stilburnt Paine, Snailiens [“Aliens”, Ellen Ripley, Gilbert Kane, Aliens] \n\r\nSome of this space trash isn't what it seems… Many egg-like objects trying to reach the Earth. Wait, some of those eggs are hatching! They're heading for our ship! Not only does the player need to collect debris, avoiding these creatures (silly-looking snail + Alien) is an important task. You must send Dr. Paine out to fight off the eggs and find out where they're coming from.\n\r\nКое-какой космический мусор — не то, чем кажется… Множество яйцеподобных объектов пытаются достичь Земли. Подождите, некоторые из этих яиц вылупляются! Они направляются к нашему кораблю! Игроку нужно не только собирать мусор, но и избегать этих существ (глупая улитка + инопланетянин). Вы должны отправить доктора Пейна отбиваться от яиц и выяснить, откуда они берутся.\r\nНо хватит предварительных ласк, предлагаем ознакомиться с персонажами, которые встретятся вам на далёких орбитах.\n\n▍ Две астронавтки NASA\n\r\nЭто не выдумка, а настоящая история. Дамочки выходили в космос ремонтировать МКС и потеряли косметичку мешок с инструментами. Говорят, он до сих пор летает на орбите, и если знать, куда смотреть, его можно даже увидеть с Земли в подзорную трубу.\n\n▍ Экспериментальный советский спутник\n\r\nВ СССР на орбиту был запущен спутник-шпион с экспериментальным ИИ на вакуумных лампах. Он возомнил себя осколком звезды, перестал отзываться на команды и до сих пор пытается выследить Кеннеди.\n\n▍ Космические угонщики\n\r\nМало кто знает, что спутники могут угонять. Румынские космические угонщики рыщут по орбитам, арканят чужие спутники, перепаивают и выдают за свои. Или разбирают на запчасти и продают на чёрном рынке.\n\n▍ Рептилоиды (ну конечно!)\n\r\nРептилоиды не выдумка! Они тайно забрасывают на Землю капсулы с яйцами, из которых после приземления вылупляются агенты. А романтики называют это падающими звёздами.\n\n▍ Мусор. Просто мусор\n\r\nМногие космонавты ленятся упаковывать и отправлять мусор на Землю. Вместо этого просто выкидывают его из шлюза. И мусорные мешки с объедками и грязными носками иногда цепляются за антенны спутников связи.\n\n▍ Станции техобслуживания\n\r\nУшлые индусы организовали для спутников орбитальные станции техобслуживания. Но они как индийский код: сделаны через назад и сами часто разваливаются.\n\n▍ Котозомби\n\r\nЭксцентричный миллиардер из Амстердама запустил в космос мумию своей любимой кошки. Под действием радиации она превратилась в летающего мертвеца и пытается обгрызать солнечные панели у кораблей.\n\n▍ Гопники с болгарками\n\r\nСуровые челябинские гопники повадились стаскивать с орбиты старые спутники и сдавать на металлолом. Пару раз даже спиливали антенны с МКС.\n\n▍ Всякое барахло\n\r\nВо время генеральных уборок на МКС космонавты открывают форточки для провертривания. Иногда сквозняком выносит всякие вещи, за которыми потом никто не гоняется по окрестностям.\n\n▍ Призрачный гонщик\n\r\nПолвека назад космонавты СССР и США устроили в космосе нелегальные гонки на кислородных баллонах. Одного из участников унесло в космос, и с тех пор его призрак скребётся и стучит в иллюминаторы кораблей, ворует со спутников гайки и дёргает за скафандры.\n\n▍ Вишнёвый шаттл\n\r\n«Хьюстон, у нас проблема» — это впервые сказал пилот шаттла, разбитого по пьяни об угол космической станции. Его обломки иногда пролетают над Висконсином и Великим Устюгом.\n\n▍ Троянский Понь\n\r\nКосмонавтам тоже хочется творчества. Так на орбите появилась копия Троянского Коня в масштабе 3:1, сваренная из отработавших ступеней ракет. Иногда она доводит до истерики впечатлительных астрономов-любителей.\n\n▍ Игроманы из звёздного казино\n\r\nНа высоте 10 тыс. км кружится подпольное космическое казино «Горизонт событий», открытое гонконгской триадой. Когда очередному проигравшемуся посетителю в голову ударяет невесомость и коктейли, его выкидывают в шлюз. Иногда в скафандре. И там уж куда долетит.\n\n▍ Лунатики (привет рептилоидам!)\n\r\nЛюди перестали летать на Луну, потому что местных — лунатиков — это раздражало. Но они и сами изредка посылают на Землю свои зонды и землеходы, которые обычно благополучно сгорают в атмосфере.\n\n▍ Астрохомяк\n\r\nКомпания малолетних самоучек построила ракету дендроэкскрементальной конструкции и запустила на ней в космос хомяка. От таких переживаний тот двинулся кукухой, поселился на заброшенном спутнике и гопстопит пролетающие мимо космические корабли.\n\n▍ Йога-бомж\n\r\nПервым космическим бомжом стал индийский космонавт: то ли денег на обратную дорогу не хватило, то ли кастой не вышел. Собирает цветмет со старых спутников, спит под солнечной панелью МКС. Иногда его пускают погреться на станцию, там он поёт мантры и подворовывает пайки с говядиной.\n\nА есть пасхалки?\r\nО да, как же без них? Ракрывать не будем, намекнем лишь, что один из героев способен помочь вам с уборкой мусора и спустить его в унитаз черную дыру за горизонт событий. \n\nИ главное: в чём сила, брат?\r\nНаша аркада — отличный способ отдохнуть от сложных задач, переключившись на мелкую моторику и тренировку реакции. И чтобы прибавить вам мотивации как можно дольше бороться за чистоту космоса, мы проводим конкурс среди лучших игроков. Всего будет три призовых места:\n\n\n1 место — Яндекс станция Миди\n2 место — Беспроводные наушники Baseus Bowie D05\n3 место — Внешний аккумулятор MagSafe Hoco Q10A, 10000 мА*ч\n\r\nА ещё все три чемпиона получат по толстовке с личной подписью космонавта Михаила Корниенко, который провёл на орбите 516 суток, дважды выходил в открытый космос и пробыл там 12 часов 17 минут. Михаил знает, насколько опасен мусор в космосе.\n\nЯ в деле!\n\nСкидки, итоги розыгрышей и новости о спутнике RUVDS — в нашем Telegram-канале 🚀  "
     },
     {
          "time": "2023-12-25T10:52:31.000Z",
          "header": "Загрязненный — значит опасный: про уязвимость Prototype Pollution",
          "link": "https://habr.com/ru/companies/pt/articles/782750/",
          "text": "Prototype Pollution (CVE-2023-45811, CVE-2023-38894, CVE-2019-10744) — не новая брешь, вы уже наверняка читали про нее и на Хабре, и на PortSwigger, и даже в научных журналах, но есть нюанс. Несмотря на большое количество публикаций, некоторые популярные решения до сих пор остаются уязвимыми для нее. Очередной пациент — библиотека на TypeScript @clickbar/dot-diver. Уязвимость CVE-2023-45827 исправлена в версии 1.0.2 и выше, поэтому мы со спокойной душой расскажем, что могло произойти с вашим продуктом, но, к счастью, не произошло.Под катом читайте о том, как нужно было пользоваться библиотекой, чтобы точно столкнуться с уязвимостью Prototype Pollution. Мы, кстати, писали про нее в своем телеграм-канале POSIdev — там свежие новости про безопасную разработку, AppSec, а также регулярные обзоры трендовых угроз и наша любимая рубрика «Пятничные мемы»!Итак, поехали!Немного о Prototype PollutionВ JavaScript все сущности являются объектами, включая функции и определения классов. Процесс наследования реализован через модель прототипов. Каждый объект в JavaScript связан с особым объектом, который называется прототипом. Объект наследует все свойства связанного прототипа. Для доступа к прототипу объекта используется встроенное поле __proto__. Поиск любого поля в объекте производится по цепочке прототипов (prototype chain): сначала это поле ищется у объекта, потом у прототипа и далее — до самого верхнего уровня наследования. Prototype Pollution позволяет атакующему «загрязнить» поле глобального объекта, которое может наследоваться пользовательскими объектами и создавать угрозу для безопасности приложения.Основные условия успешной реализации атаки Prototype Pollution:Недоверенные входные данные, которые используются для «загрязнения» глобального объекта (prototype pollution source).Наличие уязвимых функций, которые могут приводить к проблемам безопасности в коде (sink).Возможность использования «загрязненного» поля глобального объекта без его фильтрации в уязвимой функции (exploitable gadget).Механизм реализации атаки выглядит так: Атакующий «загрязняет» свойство глобального объекта через доступный объект.В приложении для уязвимой функции используется объект, который наследуется от «загрязненного» глобального объекта.Уязвимая функция использует поле из «загрязненного» глобального объекта, заданное атакующим, что приводит к нарушению безопасности.Основные поля, используемые в атаках: object.constructor.prototype.pullutedFieldobject.__proto__.pullutedField    Уязвимость в dot-diver Библиотека @clickbar/dot-diver, написанная на TypeScript (source code), предоставляет удобный API для чтения значения поля из объекта (с помощью функции getByPath) и записи значения в поле объекта (с помощью функции setByPath).Уязвимость была обнаружена в функции setByPath, которая принимает три аргумента:object — объект, для свойства которого устанавливается значение,path — шаблон пути до свойства, которое необходимо изменить,value — значение, которое будет в поле по указанному пути.При использовании функции setByPath происходит рекурсивный перебор полей в шаблоне пути. При нахождении необходимого поля ему присваивается нужное значение. Пример использования функции setByPath:Основная проблема в применении этой функции заключается в том, что если значение пути содержит путь к прототипу, то появляется возможность установить свойства прототипа, а это может привести к «загрязнению» глобального объекта.Код функции до исправления (версия 1.0.1):Этот же код после исправления (версия 1.0.2): В исправлении была добавлена проверка наличия собственного поля в объекте (с помощью функции Object.prototype.hasOwnProperty) перед его изменением. В случае отсутствия поля вызывается исключение с соответствующим сообщением.Пример эксплуатацииВ качестве примера используется приложение для учета прочитанных книг, в котором реализован механизм разграничения пользователей с разными ролями: user — с правом внесения данных о прочитанных книгах и возможностью просмотра;admin — с правом удаления книг из списка.Разграничение доступа реализуется с помощью дополнительного поля isAdmin, которое есть только у объекта user с успешным результатом проверки учетных данных для роли admin. У других пользователей это поле отсутствует.Фрагмент кода, выполняющий обработку запроса на удаление книг по ключу title и реализующий контроль прав доступа.В приложении используются следующие команды API:получить список книг: $curl -v -X GET -H http://192.168.26.1:5000/обновить список книг: $curl -v -X PUT -H \"Content-Type:application/json\" --data '{\"auth\":{\"name\":\"reader\", \"pwd\":\"books\"},\"title\":\"Tom Sawyer\"}' http://192.168.26.1:5000/удалить книгу с определенным именем: $curl -v -X DELETE -H \"Content-Type:application/json\" --data '{\"auth\":{\"name\":\"reader\", \"pwd\":\"books\"},\"title\":\"Tom Sawyer\"}' http://192.168.26.1:5000/После попытки удаления книги из списка от имени пользователя reader возвращается ответ с кодом 403 и текстом сообщения Access denied, сигнализирующий об отсутствии прав на выполнение таких действий.В запрос добавляется полезная нагрузка для атаки:$curl -v -X PUT -H \"Content-Type:application/json\" --data '{\"auth\":{\"name\":\"reader\", \"pwd\":\"books\"},\"title\":\"Tom Sawyer\", \"note\":\"__proto__.isAdmin\", \"text\":true}' http://192.168.26.1:5000/В ответ на запрос отображается успешный результат обновления списка книг. Кроме того, у глобального объекта Object появилось поле isAdmin.После повторного запроса на удаление книги из списка от имени пользователя reader в ответе возвращается уведомление об удалении книги, что сигнализирует об успешной реализации атаки и обходе механизма разграничения доступа, реализованного в приложении.Меры противодействияОсновные рекомендации для устранения проблем безопасности, связанных с уязвимостью Prototype Pollution:постоянное обновление пакетов до последних стабильных версий;поиск уязвимых компонентов с помощью SCA и SAST;обработка недоверенных пользовательских данных на входе приложения;использование конструкторов в случае отсутствия необходимости в наследовании объектов:let obj = Object.create(null),let obj = {__proto__:null};для защиты от модификации глобальных прототипов можно использовать функции API: Object.freeze() и Object.seal(). Но нужно учитывать, что они могут нарушить работу библиотек, в которых применяется механизм изменения атрибутов у глобальных прототипов.Александр БолдыревВедущий специалист группы экспертизы статического анализа приложенийДополнительные материалы\n Silent Spring: Prototype Pollution Leads to Remote Code Execution in Node.js  PortswiggerХабропостNVDPOSIdevClickbar/dot-diver на GitHub   Prototype Pollution на GitHubPrototype Pollution Prevention Cheat SheetКарточка CVE ID-CVE   CVE-2023-45827   CVSS 3.1   9,8   ID-CWE  CWE-1321   Type   Prototype Pollution   Impact   Зависит от последующего использования свойств объекта для реализации критически опасных функций (разграничения прав, исполнения кода, бизнес-логики)   Description package   Библиотека на TypeScript @clickbar/dot-diver до версии 1.0.1 включительно, которая предоставляет удобный API для чтения значения поля из объекта (функция getByPath) и записи значения в поле объекта (функция setByPath)     "
     },
     {
          "time": "2023-12-25T10:49:32.000Z",
          "header": "Личный опыт заработков в интернете: рубим бабло на студентах",
          "link": "https://habr.com/ru/articles/782996/",
          "text": "Краткая предыстория: у меня есть сын-старшеклассник, который очень хочет зарабатывать сам. В какой-то момент оказалось, что он с друзьями всерьёз обсуждает вариант «поработать курьером в доставке», и я решил найти ему более перспективное занятие, нежели карьера пешего курьера.Со словами «сын, в интернете никто не знает, что ты кот школьник» я предложил ему зарегистрироваться на сайте, делающем для студентов курсовики/контрольные/лабораторные и т.д. Точнее, регистрироваться пришлось мне, т.к. администрация сайта по какой-то странной причине хочет видеть исполнителем серьёзного человека с высшим образованием, а не ученика девятого класса. На сайте оказалось всё по взрослому: при регистрации запросили сканы документов о высшем образовании и попросили зарегистрироваться самозанятым. Дальше мне дали доступ к системе выбора заказов, и мы с сыном принялись искать то, что ему под силу сделать. Итак, что же оказалось непосильным для выполнения ленивым студентом, но вполне «по зубам» школьнику? Это были задачи типа:Оформить документ в вордеНарисовать презентациюСделать простенькие расчёты в экселеНаписать простенькую программуСделать простейшие статистические расчёты (Типа «У Васи в мешке два яблока и три мандарина...»)И т.д.\tТаких задач в системе не сказать, чтобы много, но они есть, и это позволило ребёнку заработать за две недели несколько тысяч рублей, и продолжить этот процесс далее. Но дальше речь пойдёт не об этом. \tЯ никогда раньше не соприкасался с этой стороной учебного процесса. В университете все лабораторки/курсовики делал сам, потом было преподавание в ВУЗе, но там тоже ленивые студенты таскали мне чуть-чуть переделанные лабораторки своих более активных сокурсников, либо лабораторки с прошлых лет. Доходило до смешного: однажды мне,как преподавателю, попытались сдать лабораторку, которую я делал, будучи студентом. В общем, масштабы данной отрасли меня повергли, мягко говоря, в шок. \tПервое, что у меня спросили после регистрации на сайте – не желаю ли я писать диссертации. Оказывается, спектр работ, выполняемых сайтом, не ограничивается курсовыми и и дипломными работами: научные статьи и диссертации «под ключ» там тоже есть. Любой каприз за ваши деньги. Я, разумеется, отказался. Количество висящих в системе заказов на дипломы и курсовики – поражает воображение. Причём мы изначально резко ограничили список предметов, которые нас интересуют. Если же посмотреть гуманитарные предметы, то может возникнуть подозрение, что самостоятельно на гуманитарных специальностях не учится вообще никто. Второй момент, который меня поразил – это обилие задач на расчёт усилительных каскадов на транзисторах. Впрочем, возможно, это «ошибка выжившего»: подобные задачи болтаются очень долго, никто их не берёт, поэтому кажется, что их много.Ну и плюс то, что я в силу своей работы обращаю внимание на такие задачи. Тем не менее, факт остаётся фактом – задач на расчёт «усилителей сигнала на транзисторах» много. Я много лет работаю схемотехником, и за всё это время с задачами на расчёт усилительного каскада на транзисторе не сталкивался ни разу. Более того – в организации, где я работаю, с такой задачей хотя бы раз сталкивались всего пара человек (и то – они их нифига не рассчитывали, насколько я знаю). Впрочем, это довольно полезное знание, если бы его преподавали нормально. И вот тут вылезает...Третий момент, который меня поразил: это обилие заданий древних, как дерьмо мамонта. Например, вышеупомянутые задачи на расчёты транзисторных каскадов: я ни разу не видел в них фразы «подберите элементную базу». Всегда «рассчитать каскад с ОЭ/ОБ/ОК на транзисторе XXX». Самый новый из предлагаемых в разных задачах транзисторов снят с производства в 2012-ом году. А самый древний – снят с производства с распадом СССР. Вишенкой на торте является то, что задача с этим самым СССР-овским транзистором прилетела из Бауманки. Люди из Бауманки, кто у вас там такой некрофил? Расскажите ему что ли, что электронная промышленность развивается, что задания надо бы актуализировать хотя бы раз в пятилетку... Причём это касается не только транзисторов. Ребёнок долго мучился с одним вордовским документом: там требовался объект WordArt. Проблема в том, что именно такой объект есть только в ворде 2003, уже в 2007-ом эти объекты существенно переработали. Пришлось ставить ребёнку виртуалку и 2003-ий ворд. Ещё попадались задачи, которые надо было обязательно делать в программе, которая загнулась пятнадцать лет назад (прямо даже странно, что их никто не берёт, да?). Куча задач на программирование древних микроконтроллеров на ассемблере... С другой стороны – иногда попадаются реально интересные/забавные  задачи, жаль только, что их очень мало. Из того, что запомнилось: весёлая задача на алгоритм быстрого вычисления обратного квадратного корня, со ссылками на квейк;Задача на умножение чисел с плавающей точкой при помощи жёсткой логики Задача на написание доклада для пятиклассника!!! Домашние поделки, выполняемые силами родителей, вышли на новый уровень :)\tОтдельную улыбку вызывает система, по которой оценивается стоимость задачи. Я не знаю нюансов, но иногда бывают задачи, в которых за несколько сотен рублей надо буквально пару раз шевельнуть мышкой (что вызывало дикий восторг у ребёнка), а иногда – за 200-300 рублей просят сделать просто конский объем работ. Забавно, что сын поначалу хватал такие задачки, а потом научился таки ценить своё время. Плюс один полезный навык в копилку :)\tВ целом – познавательный опыт. Ребёнок увидел, что можно зарабатывать деньги умом, а не морозя задницу с рюкзаком Яндекс-доставки на спине, познал суть понятия «дедлайн», а также начал заниматься долгосрочным планированием типа «пошью пиджак с отливом и в Ялту» «ещё заказы поделаю, и куплю себе видеокарту»  "
     },
     {
          "time": "2023-12-25T10:40:50.000Z",
          "header": "Секрет внутренней связи: откровения Маруси о том, как она научилась слушать себя",
          "link": "https://habr.com/ru/companies/vk/articles/782944/",
          "text": "Привет, Хабр! Меня зовут Коля Кремер, уже 4 года я работаю в команде мобильного приложения Маруси, где мы постоянно стараемся сделать так, чтобы с нашим помощником было удобно и интересно общаться. Я несколько раз начинал писать и откладывал этот ретроспективный пост, но потом к нему подключились ребята из нашей команды и помог довести его до публикации. Хочу поблагодарить Влада Голоднюка, старшего программиста, и Пашу Муханова, руководителя мобильной разработки, и рассказать сообществу Хабра о том, как мы отучили Марусю в приложении триггериться на себя и научили правильно слышать и понимать ваши запросы.Что такое самотриггерение?Когда четыре года назад мы запустили Марусю, она уже была сообразительной и помогала решать самые разные задачи: от поиска интересных фильмов в кинотеатрах и треков в VK Музыке до рассказа сказок для детей и прогнозов погоды. Кроме того, она могла (и может) поддерживать беседу и давать осмысленные ответы. Однако ряд пользователей сталкивался с ситуацией, когда помощник останавливался в середине ответа, как будто обдумывая следующее слово. Это сбивало с толку, хотя причина была в том, что Маруся внимательна к вам во время разговора, чтобы собеседник мог прервать её если необходимо. Следовательно, когда в её ответе или ваших словах встречаются KWS (key word spotter — слово, на которое голосовой помощник триггерится), то, слыша слово «Маруся» (которое и есть KWS), она думает, что вы обратились к ней, останавливая выполнение всех текущих команд. Очевидно, что это не самая приятная ситуация и для нас и для пользователя. Именно это называется проблемой самотриггерения — ситуации, при которой голосовой  помощник активируется (триггерится) сам на себя. Однако не стоит думать, что Маруся находится в постоянном состоянии самотреггерения. Для большой части запросов у неё, как и у всех retrieval-based ассистентов, есть набор стандартных ответов и шаблонов, из которых она выбирает наиболее подходящий. Как правило, их конечное число, поэтому мы храним их на сервере не в текстовом виде, а как текст и аудио (tts — text to speech — аудиодорожка с озвучкой текста Маруси). Вместе с этим для каждой такой аудиодорожки можно создать и хранить timestamp (временные метки), в которых есть триггерное слово «Маруся». Это необходимо для того, чтобы для каждого такого timestamp сервер слал команду skip_kws на клиент (мобильное приложение) для блокировки микрофона. Как это работает? Пользователь что-то спрашивает у Маруси, например, какая завтра погода, а она ищет наиболее подходящий ответ. Если он есть в списке готовых с аудиодорожками и командами skip_kws, то всё работает верно. В этом случае сервер присылает в качестве ответа текст, аудиодорожку и команду skip_kws с параметрами на каких секундах приложение нужно блокировать микрофон. Далее приложение показывает пользователю текст, начинает озвучивать аудиодорожку (TTS) и в нужный момент отключает микрофон, чтобы исключить проблему самотриггерения.А что если для ответа нет готового TTS, т.е. он генерируется нейросетью или это подкаст или трек VK Музыки, то команды skip_kws нет, и приложение не знает, когда нужно блокировать микрофон. Поэтому, если в ответе есть триггерное слово, то Маруся реагирует сама на себя.Так выглядит развилка.На большинство ответов Маруся отвечает без запинок, что в целом очень хорошо, плюс мы постоянно получаем обратную связь (отзывы в магазинах, обращения в поддержку группы в ВКонтакте, чат с корпоративными  пользователями и т. д.) и работаем над улучшениями. При этом жалоб на самотриггерение мы получили единицы на миллионы пользователей в месяц. Как мы обнаружили проблему самотриггерения? На одном из UX‑исследований с фокус группами мы обнаружили, что пользователи жаловались на самотриггерение, говоря о том, что Маруся «тормозит» и «сбивается». То есть пользователи воспринимали это не как проблему самотриггерения, они просто считали, что Маруся не может ответить на вопрос. Стало понятно, что проблема немного больше, чем мы предполагали. Для исследования мы собрали с добровольных тестеров выборку в 2000 случайных аудиодорожек, в которых проверили нулевой чанк — начало аудиодорожки, т. е. момент активации Маруси. Результаты не были плачевными, но и не обрадовали нас: 6% из 2000 активаций были самотриггерением. Небольшое отступление, важно понимать, что если бы починка бага занимала мало времени и ресурсов, то мы бы запланировали её в ближайший релиз в рамках ZBP (Zero Bug Policy), но готового простого решения не нашлось, поэтому пришлось начинать с его поиска.Как мы выбирали из всех возможных вариантов решенияДля начала мы обратились к опыту конкурентов, посмотрели, как сегодня работают  их голосовое ассистенты и пришли к следующим выводам: Конкурент 1: Во время озвучки TTS полностью выключает микрофон. Сценарий нам не подошел, т.к. пользователю нужно дождаться, пока ассистент закончит вещать или перебить его тапом по кнопке. После этого можно опять активировать ассистента тапом или по kws и задать новый вопрос.Конкурент 2: Перед использованием требует дообучения модели на голосе пользователя. Что это значит? На онбординге ассистент просит пользователя зачитать текст, и записанный голос пользователя использует для дообучения локальной модели, которая распознает KWS. Таким образом, ассистент отличает вызов KWS пользователем от самого себя. Продуктовое решение классное, хорошо решает проблему самотриггерения, но требует долгой работы ML-команды. Забрали в бэклог.Конкурент 3: Помощник отключает микрофон девайса в момент озвучивания им ключевого слова, в нашем случае Маруся отключала бы микрофон каждый раз, когда она должна сказать слово «Маруся» при ответе на вопрос пользователя. Решение неплохое, но есть минусы: не работает на эхо, создаваемое другими приложениями: стриминг музыки, подкасты и т. д. Кладем в бэклог со звездочкой.Конкурент 4: также как и мы, ассистент страдает проблемой самотриггерения.Затем мы попытались найти простое решение. Например, с помощью активных инструментов. Сначала про AndroidПри инициализации записи объекту передается источник записи с помощью MediaRecorder::setAudioSource(int).Для микрофона имеется стандартный параметр MediaRecorder.AudioSource.MIC, который будет возвращать в колбек аудиодорожку, записанную микрофоном, после постобработки средствами устройства.Также имеются дополнительные константы:MediaRecorder.AudioSource.VOICE_COMMUNICATIONMediaRecorder.AudioSource.VOICE_RECOGNITIONИх добавили для обработки входящего и исходящего потока средствами ОС, для лучшего качества общения. Согласно документации, они главным образом существуют для шумо и эхоподавления, то есть для решения нашей проблемы.Также существует класс AcousticEchoCanceler, который позволяет отдельно подключать системное эхоподавление к отдельной сессии, но, как можно заметить по его интерфейсу, метод isAvailable() говорит, что это может работать не на всех Android-устройствах. На самом деле этот класс задействует те же системные инструменты, что и MediaRecorder при передаче описанных выше констант VOICE_COMMUNICATION и VOICE_RECOGNITION, но кастомные прошивки могут вообще этого не делать, поэтому если вы решитесь использовать эти инструменты, следует отдельно пытаться подключить эхоподавление для большей надежности.Из плохих новостей: то, как будет обрабатываться запись не имеет конкретной спецификации, а движок системного эхоподавления реализован каждым отдельным производителем в недрах операционной системы. Читая между строк: на большинстве устройств будет работать очень плохо или вообще не будет.В итоге нативное решение в большинстве случаев никак не работало. Все зависело от конкретной модели: в околофлагманских устройствах удаляло эхо до определенной громкости динамиков, а в смартфонах попроще не только не работало, но и искажало проигрываемый звук из динамиков из-за попытки обработать исходящий поток (создавало артефакты и помехи).Теперь про  iOSРеализуется максимально просто с помощью стандартных инструментов: класс AudioUnit.desc.componentSubType = kAudioUnitSubType_VoiceProcessingIOНативно решение работает частично: немного искажает исходящий звук и сильно приглушает его: создает эффект, будто звук проигрывается из банки, но работает достаточно бодро. Как можно узнать из документации: системное эхоподавление задумывалось как решение для приложений звонков, которые могут уживаться с такими недостатками.Обобщая результат по двум платформам, можно резюмировать, что системное эхоподавление работает с большим количеством ошибок и может искажать исходящий звук, что не подходит для голосового ассистента, который использует звук как средство коммуникации — benefits < drawbacks. Не берём в бэклог.Как это делают умные колонки?Умная колонка — полностью кастомный продукт со своей прошивкой. Поэтому она может получать в реальном времени поток с микрофона и звук из динамиков, вычищая шумы и получая чистый звук. Такая реализация — эталон по отношению к тому, что должно быть реализовано в системном движке эхоподавления смартфонов, и должно быть реализовано средствами производителя, но, как было написано ранее, реализовывается на малом количестве флагманских смартфонов. Поэтому для мобильного приложения это решение не подходит. Сторонние библиотекиИх нет и не может быть, так как решение по эхоподавлению должно быть очень низкоуровневым. На уровне приложения такое решение не представляется возможным.Как делалиСамым оптимальным решением является блокировка микрофона, но не во время  всего проигрывания TTS, а только ключевого слова. Механизм выглядит простым, а значит надежным — компромисс между затрачиваемыми ресурсами и результатом.Из этого вытекает два вопроса: откуда берем звуковую дорожку и каким образом будем понимать, когда нужно отключать микрофон (т. е. некий обработчик звуковой дорожки)? В качестве идеального решения была бы возможность получать весь звук, который проигрывается устройством, но во‑первых, это невозможно сделать из‑за особенностей OS, во‑вторых, это не очень этично.В нашем приложении на Android для проигрывания звуков мы используем ExoPlayer2В нём есть возможность перехватывать аудиодорожку на этапе её чтения из источника, за что отвечает интерфейс DataReader. Соответ ственно, самый простой способ получить аудиодорожку — написать свой DataSource, который и является наследником DataReader, в методе int read(byte[] buffer, int offset, int len gth) которого мы и будем производить необходимые вычисленияВ iOS грузим данные через URLSession. В методе init можно передать ​​URLSessionDelegate, который и необходимо реализовать в качестве колбека для данных.Для вычисления ключевого слова из потока микрофона мы используем несколько вероятностных моделей, которые объединены в библиотеку на C++, которую мы используем через Java Native Interface и Swift bridging.Логично, что если мы используем эту модель для одного источника звука, мы можем использовать её и для анализа других источников, так как в конечном счете звук представлен в виде байтового массива. При этом модели не важно, какого он происхождения. Таким образом мы будем прогонять наш звук из плеера через модели машинного обучения для поиска ключевого слова. Здесь важно отметить, что такие модели обычно обучаются под конкретный формат аудио, поэтому предварительно следует убедиться, что формат совпадает. В противном случае необходимо привести массив к нужному формату или переобучить модели. В нашем случае формат совпадал, поэтому перекодирование и переобучение не потребовалось.Также необходимо брать в расчет, что несколько дорожек может загружаться параллельно, либо может существовать несколько инстансов плеера одновременно, которые подготавливают дорожки (на самом деле это плохая практика из-за ограничений по использованию кодеков на смартфоне, но сейчас разговор не об этом), тогда необходимо обеспечить параллельность вычислений для каждой аудиодорожки в разных потоках. В нашем случае нативная библиотека не была рассчитана на многопоточную работу, так как использовалась только для микрофона в отдельном потоке, из-за чего её нельзя было корректно использовать с плеером, поэтому нам пришлось доработать её для работы в многопоточном режиме.Допустим, мы получили, что в конкретном месте массива байтов модель нашла ключевое слово, но все же как мы поймем, когда надо отключать микрофон?Как сказал ранее, модель работает с аудио определенного формата, следовательно, мы можем вычислить количество байтов в секунду и по расположению нужного участка на всем массиве вычислить нужное время на таймлайне аудиодорожки. Осталось повесить Listener на прогресс плеера и отключать микрофон на найденных интервалах.Примерная схема работы алгоритма.И всё?Нет, не всё. Когда всё уже было сделано, оказалось, что одна и та же модель не всегда находит ключевое слово в исходной аудиодорожке, если оно не точно такое, а искажено или просто похоже по звучанию. Например, если вместо четкого «Маруся» было произнесено «Марущ» или любое другое похожее на ключевое слово, но находит его во входящем потоке, который попадает в микрофон, причем чем ниже громкость динамика, тем чаще происходит такая ошибка.Всё дело в том что анализировали мы идеально чистый звук, а эхо, которое попадает в микрофон искажается по пути (из-за обработки исходящего и входящего звука операционной системой, плохого качества динамиков или микрофона и наложения внешних шумов), из-за чего в ряде случаев искажение звука приводило к тому, что модель начинала слышать ключевое слово там где его на самом деле нет.Для исправления этого эффекта потребовалась донастройка модели. Сама модель не возвращает булевое значение, является ли оно ключевым словом или нет, но возвращает вероятность этого, а подставив нужные пороги вероятностей, уже можно получить булевое значение. Так как для модели, которая использовалась микрофоном, уже были заданы необходимые вероятностные значения, необходимо было изменить коэффициенты для модели, которая использовалась при анализе плеера.Здесь мы будем рассматривать модель, которой передаются пороги вероятностей в качестве коэффициентов, как булеву функцию от байтового массива f1(a, x), где a — искомые коэффициенты, а x — массив байтов. Как упоминалось ранее, параметры модели для микрофона уже заданы, следовательно она является функцией с заданными коэффициентами f2(x), при этом исходный массив байтов искажается по пути до f2, следовательно существует некоторая случайная функция искажения b(x), которая возвращает новый массив байтов. Ранее упоминал, что эта функция в том числе зависит от громкости звука динамиков, поэтому точнее будет ввести параметр v, который принимает целочисленные значения 1–10 (10–100%): b(v, x)Таким образом, нам необходимо подобрать такое значение a, при котором функции f1(a, x) и f2(b(v, x)) как можно чаще выдают одинаковый ответ. т. е. Такие значения, что f1(a, x) ≈ f2(b(v, x))Так как для нас пороги вероятностей являются целочисленными значениями от 0 до 100, то найти оптимальное значение можно простым перебором. Так как все это происходит на реальных девайсах, подбирать мы будем там же через написанный скрипт. Необходимо собрать большой массив аудиодорожек в качестве тестового набора данных, где в том числе будут различные искаженные или похожие варианты ключевого слова, после чего необходимо проиграть эти аудиодорожки при разных значениях громкости динамика, поймать микрофоном и проанализировать. Ответы для разных значений громкости всегда можно усреднить. Далее анализируем исходные дорожки с разными порогами вероятностей в цикле и находим те, при которых количество ошибок минимальное, при этом стоит учитывать, что ложное срабатывание при анализе исходной дорожки является менее серьезной проблемой, чем пропуск ключевого слова, поэтому следует добавить разные веса этим ошибкам.Что в итоге?После разработки решения для начала мы раскатали его на небольшую аудиторию, проверили эффективность: доля самотриггерений голосового помощника в потоке упала с 6% до 0,1%, пользователи остались довольны. Сейчас мы обновляем SDK для VK и Почты, чтобы Маруся больше нигде на мобильных устройствах не триггерилась.    "
     }
]